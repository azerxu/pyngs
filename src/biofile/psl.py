#! /usr/bin/env python
# coding: utf-8

# **********************************************************************
# file: psl.py
#
# parse blat program output psl file
# **********************************************************************

class Psl(object):
    """One line of PSL lines represent alignments, and typically taken from
    files generated by BLAT or psLayout.
    """
    def __init__(self, match, mismatch, repmatch, n_count, q_gap_count,
                 q_gap_bases, t_gap_count, t_gap_bases, strand, qname,
                 qsize, qstart, qend, tname, tsize, tstart, tend,
                 block_count, block_sizes, qstarts, tstarts,
                 qseq=None, tseq=None):
        """PSL one line sepatate by tab, position value are 0-based"""
        # 1  Number of bases that match that aren't repreats
        self.match = int(match)

        # 2  Number of bases that don't match
        self.mismatch = int(mismatch)

        # 3  Number of bases that match but are part of repeats
        self.repmatch = int(repmatch)

        # 4  Number of N bases
        self.n_count = int(n_count)

        # 5  Number of inserts in query
        self.q_gap_count = int(q_gap_count)

        # 6  Number of bases inserted in query
        self.q_gap_bases = int(q_gap_bases)

        # 7  Number of inserts in target
        self.t_gap_count = int(t_gap_count)

        # 8  Number of bases inserted in target
        self.t_gap_bases = int(t_gap_bases)

        # 9  '+' or '-' for query strand. for translated alignments,
        #    second '+' or '-' is for genomic strand
        self.strand = strand

        # 10 Query sequence name
        self.qname = qname

        # 11 Query sequence size
        self.qsize = int(qsize)

        # 12 Alignment start position in query
        self.qstart = int(qstart)

        # 13 Alignment end position in query
        self.qend = int(qend)

        # 14 Target sequence name
        self.tname = tname

        # 15 Target sequence size
        self.tsize = int(tsize)

        # 16 Alignment start position in query
        self.tstart = int(tstart)

        # 17 Alignment end position in query
        self.tend = int(tend)

        # 18 Number of blocks in alignment(a block contains no gaps)
        self.block_count = int(block_count)

        # 19 Comma-separated list of sizes of each block
        self.block_sizes = self._deal_comma_string(block_sizes)

        # 20 Comma-separated list of starting positions of each block in
        #    query
        self.qstarts = self._deal_comma_string(qstarts)

        # 21 Comma-separated list of starting positions of each block in
        #    target
        self.tstarts = self._deal_comma_string(tstarts)

        self.qseq = qseq                # query sequence
        self.tseq = tseq                # target sequence

    def _deal_comma_string(self, comma_string):
        """split comma_string to int value list"""
        return [int(val) for val in comma_string.split(',') if val]

    def __repr__(self):
        qstarts = ','.join([str(qstart) for qstart in self.qstarts + ['']])
        qends = ','.join([str(qend) for qend in self.qends + ['']])

        return '\t'.join(map(str, (
            self.match, self.mismatch, self.repmatch, self.n_count,
            self.q_gap_count, self.q_gap_bases, self.t_gap_count,
            self.t_gap_bases, self.strand, self.qname, self.qsize,
            self.qstart, self.qend, self.tname, self.tsize, self.tstart,
            self.tend, self.block_count, self.block_sizes,
            qstarts, tstarts)))


def parse(fname):
    with open(fname, 'r') as handle:
        for line in handle:
            # find break line
            if line.startswith('-----'):
                break
        for line in handle:             # PSL Data lines
            line = line.rstrip()        # trim right newline char
            if not line:                # ignore blank line
                continue
            items = line.split('\t')
            yield Psl(*items)


def read(fname):
    return parse(fname)

